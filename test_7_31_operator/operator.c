#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>



//表达式求值的顺序一部分是由操作符的优先级和结合性决定的   也会发生类型转换

//隐式类型转换：看不到就发生了转换
//int main()
//{
//	char a = 3; 
//	//00000000000000000000000000000011    也是补码
//	//因为a是一个字节 8个比特位 所以发生截断  就是取最低的8个比特位 00000011
//	//00000011   这里面就是a的二进制序列
//	char b = 127;
//	char c = a + b;//这里就会发生整型提升，先提升为整型，然后在计算
//	//00000000000000000000000001111111	   127的原反补
//	//01111111    发生截断之后 就是这个  就是 b
//
//	//a 和 b 都是char类型 自身大小都是1个字节 所以这里计算的时候要进行整型提升
//	//整型提升：负数的整型提升最高位补的是 1 
//	//b的符号位是0 所以前面补的都是 0    a也是这样
//	//如果是无符号数 只能补 0  
//
//	//00000000000000000000000000000011    这就是a整型提升后的结果
//	//00000000000000000000000001111111    这就是b整型提升后的结果
//	//00000000000000000000000010000010    这是加起来之后的结果      所以放的char里面 继续截断
//
//	//10000010    这就是 c 的大小   是有符号的  所以继续整型提升
//	//11111111111111111111111110000010    //这些是补码  所以要还原成原码
//	
//	//10000000000000000000000001111110    //这里结果就是-126
//
//	printf("%d\n", c);//-126 因为转化为原码就是这样
//
//	return 0;
//}


//整型提升就是大小比 int 小的 要提升
//int main()
//{
//	char a = 0xb6;
//	short b = 0xb600;
//	int c = 0xb6000000;
//	if (a == 0xb6)
//		printf("a");
//	if (b == 0xb600)
//		printf("b");
//	if (c == 0xb6000000)
//		printf("c");      //只打印 c 因为 a b 会发生整型提升 所以值会有变化
//	return 0;
//}


//int main()
//{
//	char c = 1;
//	printf("%u\n", sizeof(c));  //1   因为是打印无符号数
//	printf("%u\n", sizeof(+c)); //4   因为发生了整型提升  所以是4
//	printf("%u\n", sizeof(-c)); //4   因为也是整型提升 所以是4
//	return 0;
//}


//int main()
//{
//	int a = 4;
//	float f = 4.5f;
//	float r = a + f;//这里是 int 转化为float  是算术转换 把精度低的转化为精度高的
//	return 0;
//}


//操作符的三个属性
//1 优先级
//2 结合性
//3 控制求值顺序


//相邻操作符才看优先级    优先级决定的是相邻操作符
//int main()
//{
//	int a = 2;
//	int b = 4;
//	int c = a + b * 3;//操作符相邻  *的优先级比+ 高 所以先算*
//
//	//如果都是 + 的话 从左到右运算
//
//	printf("%d\n", c);
//	return 0;
//}


// c + --c;  这个表达式也有问题  因为不知道算的是 --c 之前的 c 还是 --c 后的 c 
// 这个地方用括号也不能  因为不知道是不是先进行 --c 


//非法表达式：在不同编译器下面的结果各不相同
//int main()
//{
//	int i = 10;
//	i = i-- - --i * (i = -3) * i++ + ++i;
//	printf("i = %d\n", i);//非法表达式：在不同编译器下面的结果各不相同
//	return 0;
//}



//写出的表达式不能确定唯一计算路径 就说明这个代码有问题
//int fun()
//{
//    static int count = 1;
//    return ++count;
//}
//int main()
//{
//    int answer;
//    answer = fun() - fun() * fun();
//    printf("%d\n", answer);//输出 -10  因为先把 3个fun的值算出来 然后再计算  2 - 3*4  
//    //这个代码依然有问题 因为不知道先调用哪个
//    return 0;
//}
