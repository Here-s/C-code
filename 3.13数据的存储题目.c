#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<string.h>



int main()//在屏幕上打印杨辉三角：上面两个数相加=下面的数 就相当于 每个数等于上面的数+左上方的数 
//发现只有第三行第二个才开始算
{
    int arr[10][10] = { 0 };
    int i = 0;
    int j = 0;
    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 10; j++)
        {
            if (j == 0)
            {
                arr[i][j] = 1;//j=0,就是竖着的那一列，变成0
            }
            if (i == j)
            {
                arr[i][j] = 1;//对角线上的元素，设置为1
            }
            if (i >= 2 && j >= 1)
            {
                arr[i][j] = arr[i - 1][j] + arr[i - 1][j - 1];
            }
        }
    }
    for (i = 0; i < 10; i++)//打印出来
    {
        for (j = 0; j <= i; j++)//这里是第一行打印一下，第二行两下，第三行三下，
        {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }

	return 0;
}
//杨辉三角
      //   1
      //  1 1
      // 1 2 1
      //1 3 3 1
//1
//1 1
//1 2 1
//1 3 3 1
//1 4 6 4 1  //就相当于 每个数等于上面的数+左上方的数
//int main()
//{
//	char a[1000] = { 0 };//存放的是0 都是有符号的char 范围是-128 - 127
//	int i = 0;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;//第一次是-1，-2，-3，。。。。。 -128，127，126，。。。。。1，0，-1.。。。
//	}
//	printf("%d\n", strlen(a));//0之后 就是/0,所以是255个字符
//	return 0;
//}

//int main()//在32未大端模式处理器上变量b等于
//{
//	unsigned int a = 0x1234;//16个二进制位，所以是2个字节，因为是大端 所以放的方式是 00 00 12 34
//	unsigned char b = *(unsigned char*)&a;//强制类型转化 只能访问一个字节 所以访问的是00
//	//变量b是00，不能在编译器上验证，因为编译器是小端存储
//	return 0;
//}

//int main()//程序的执行结果是
//{
//	unsigned char a = 200;//无符号的字符 一个字节 8个比特位 存储的范围是0-255 因为全是1 就是255
//	//因为是无符号数，所以第一位就不是符号位 所以高位补0  正数的原反补相同
//	unsigned char b = 100;
//	unsigned char c = 0;
//	c = a + b;//加起来放不下 最多放255，但还是强行放 所以会整型提升 a:11001000   b:01100100  所以加完c存的是00101100  高位补0 是44
//	//a+b的整型提升是300 因为提升为整型，所以是4个字节 
//	printf("%d %d", a + b, c);//300 44
//	return 0;
//}
//大端 高位放在低地址，低位放在高地址
//小端 低位放在低地址，高位放在低地址
