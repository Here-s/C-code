#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<stddef.h>
//#pragma pack(1)//修改默认对齐数是1
//#pragma pack()//默认对齐数返回原来的数


//结构体设计的时候 要尽量不浪费空间 ：让占用空间少的成员尽量放在一起
//struct S1
//{
//	//这个放的时候 就会浪费掉空间   从 0 偏移处开始放  int是从 4 的整数倍开始放的 
//	//所以这里的 int 就是从 4 开始放的  结构体的整体大小是最大偏移量的整数倍 
//	//这里的最大偏移量是 int 是 4 所以是12 
//	char c1;
//	int i;
//	char c2;
//};
//struct S2
//{
//	char c1;
//	char c2;
//	int i;
//};
////vs 默认对齐数是8 但是可以修改默认对齐数  #pragma pack() 要修改谁 就把它放在谁的前后
//int main()
//{
//	struct S1 s1;//采用默认对齐数 8 那么 char int char 的默认对齐数都是1 就不用对其了
//	//那么这三个就可以挨着放  不对其的话 不浪费空间 但是效率肯=可能没原来那么高
//	//设置默认对齐数 一般是 2 的平方
//	printf("%d\n", sizeof(s1));
//	return 0;
//}


//百度笔试题：写一个宏，计算结构体中某变量相对于首地址的偏移，并给出说明  
//考察的是offsetof 宏的实现

//offsetof 返回一个成员在结构体内部的位置  返回是无符号整型
//struct S1
//{
//	char c1;
//	int i;
//	char c2;
//};
//int main()
//{
//	struct S1 s1;//
//	printf("%u\n", offsetof(struct S1, c1));//offsetof 返回一个成员在结构体内部的位置  返回是无符号整型
//	printf("%u\n", offsetof(struct S1, i));
//	printf("%u\n", offsetof(struct S1, c2));
//	return 0;
//}


//结构体传参  用结构体接收
//struct S
//{
//	int data[1000];
//	int num;
//};
//void printf1(struct S tmp)
//{
//	for (int i = 0; i < 10; i++) {
//		printf("%d ", tmp.data[i]);
//	}
//	printf("\nnum = %d\n", tmp.num);
//}
//void printf2(const struct S* ps)
//{
//	for (int i = 0; i < 10; i++) {
//		printf("%d ", ps->data[i]);
//	}
//	printf("\nnum = %d\n", ps->num);
//}
//int main()
//{
//	struct S s = { {1,2,3,4,5,6,7,8,9,10},100 };
//	//printf1(s);//这里是值拷贝  浪费空间  因为结构体过大的话 压栈浪费更多的性能
//	//但是值传递的话 源数据更安全  但是址传递的话 加个const 就好了
//	printf2(&s);//这里是址传递  不浪费空间
//	return 0;
//}


//位段    结构体实现位段的能力
//位段的声明和结构是类似的，有两个不同：
	//1.位段的成员必须是 int、unsigned int 或signed int   char 整型家族应该都行
	//2.位段的成员名后边有一个冒号和一个数字。

//struct A
//	//一上来 先开辟4个字节 32个比特位  a b c  都是用的这32个比特位  当不够的时候 又开辟了4个字节
//	//所以就是 8个字节
//{
//	int _a : 2;//_a  放的成员 只需要两个比特位  就能表示想要的状态
//	//这样放的话 当一个数很大时 会发生截断 
//	int _b : 5;//_b  只需要5个比特位
//	int _c : 10;//分配10个比特位
//	int _d : 30;//分配30个比特位
//};
////1个字节是8个比特位   
//
////位段上的空间 是按照需要 一个字节 或4个字节 来开辟的   因为有不确定因素  所以不能跨平台
//int main()
//{
//	//位段是可以用来节省空间的   位段的位 是二进制位
//	//因为有些东西只需要几种状态表示就行了  比如性别：男  女  保密  可以用 00 01 10 来表示
//	printf("%d\n", sizeof(struct A));//没有 : (冒号) 的话是16  但现在是 8
//	//这里是47个比特位 6个字节就够了 但结果是8个字节  浪费了两个字节
//
//	//8个字节 是因为一上来 先开辟4个字节 32个比特位  a b c  都是用的这32个比特位  当不够的时候 又开辟了4个字节
//	//所以就是 8个字节
//	return 0;
//}


//位段的内存分配
//因为位段的空间分配规则不一样 所以跨平台的话 可能会导致结果差异

//struct s
//{
//	char a : 3;
//	char b : 4;
//	char c : 5;
//	char d : 4;
//};
//int main()
//{
//	//位段的内存 这里是 一个字节一个字节开辟的 一次8个比特位 当8个比特位不够放一个元素的时候
//	//剩下的比特位就被浪费了 就继续开辟一个字节 8个比特位   vs编译器是下是这样做的
//
//	//位段不能使用 offsetof 因为位段上的地址被忽略
//	struct s s = { 0 };
//	s.a = 10;
//	s.b = 12;
//	s.c = 3;
//	s.d = 4;
//	return 0;
//}


//位段的跨平台问题
	//1. int 位段被当成有符号数还是无符号数是不确定的。
	//2. 位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机
	//器会出问题。16位机器 int是两个字节 最大是 16个比特位
	//3. 位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。
	//4. 当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是
	//舍弃剩余的位还是利用，这是不确定的。

//跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在。


//位段的应用 用来封装数据包  将数据设计为位段 就能加快数据的传递 


//枚举: 就是一一列举   把可能的值一一列举
//就像性别  星期  就能使用枚举
//enum  枚举关键字

//枚举让可能的取值有了意义 方便使用
//enum Color//三颜色
//{
//	RED = 5,//让RED 从5开始 那么剩下的两个常量 就是 6 7   5 就是对其初始化
//	GREEN = 6,
//	BLUE = 7
//};
//int main()
//{
//	//枚举的常量是有值的 默认从 0 开始
//	//printf("%d\n", RED);//0
//	//printf("%d\n", GREEN);//1
//	//printf("%d\n", BLUE);//2
//
//	enum Color c = GREEN;//将 GREEN 的值赋给 c
//	enum Color d = 4;//如果是cpp文件的话 就会报错 因为cpp文件认为d 是枚举类型 4 是整型 所以报错
//	if (c == GREEN)
//	{
//		printf("绿色\n");
//	}
//	return 0;
//}


//枚举的优点
	//1. 增加代码的可读性和可维护性
	//2. 和#define定义的标识符比较枚举有类型检查，更加严谨。  define 就是把值直接给替换了
	//3. 防止了命名污染（封装）防止暴露在全局范围内
	//4. 便于调试  可以在调试的时候 看它的值
	//5. 使用方便，一次可以定义多个常量


//enum Option
//{
//	EXIT,
//	ADD,
//	SUB,
//	MUL,
//	DIV
//};
//void menu()
//{
//	printf("*** 1.add  2.sub  3.mul  4.div  0.exit  ***");
//}
//int main()
//{
//	
//	int input = 0;
//	do
//	{
//		menu();
//		printf("请选择\n");
//		scanf("%d", input);
//		switch (input)
//		{
//			//使用枚举 使得代码的可读性越来越高
//		case ADD:
//			//加法
//			break;
//		case SUB:
//			break;
//		case MUL:
//			break;
//		case DIV:
//			break;
//		}
//	} while (input);
//	return 0;
//}


//枚举的变量就是可能取值 都是整数 所以是整型 是 4 个字节


//联合体：也是一种特殊的自定义类型
//这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块空间（所以联合也叫共用体）

//union Un//union 联合体关键字
//{
//	char c;
//	int i;
//};
//int main()
//{
//	union Un u = { 0 };
//	printf("%d\n", sizeof(u));//4 
//
//	//发现下面这三个地址一样   因为第一个字节 c和i都在用  共用同一块字节  所以字节大小就是类型最大的字节
//	//所以 c 和 i 只能同时使用一个 因为如果改变 c 的话 i也被改变了 改变 i的话 c也被改变了
//	printf("%p\n", &u);
//	printf("%p\n", &(u.c));
//	printf("%p\n", &(u.i));
//	return 0;
//}


//判断当前的机器的大小端存储
//int main()
//{
//	int a = 1;//0x 00 00 00 01    01是高地址 
//	//01 00 00 00  这种是 小端存储
//	//00 00 00 01  这种是 大端存储
//	//如果第一个字节是 1 那么就是小端  否则就是 大端
//	//char* pc = (char*)&a;
//	//if (*pc == 1)//解引用 拿到一个地址 
//	//{
//	//	printf("小端\n");
//	//}
//	//else {
//	//	printf("大端\n");
//	//}
//
//	union U
//	{
//		char c;
//		int i;
//	}u;
//	u.i = 1;
//	if (u.c == 1)//因为是联合体 共用一块字节 所以就可以这样判断
//	{
//		printf("小端\n");
//	}
//	else {
//		printf("大端\n");
//	}
//	return 0;
//}


//联合体大小的计算
	//联合的大小至少是最大成员的大小。
	//当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。

//联合体也存在对齐
int main()
{
	union Un1
	{
		char c[5];//5 个字节  对齐是 1 
		int i;//4个字节  对齐是 4  最大字节是 4 所以联合体的大小是 8 
	};
	union Un2
	{
		short c[7];//14 个字节 对齐数是 2 
		int i;// 对齐数是 4   因为14 不是4 的对齐数  所以是16 
	};
	//下面输出的结果是什么？
	printf("%d\n", sizeof(union Un1));//8
	printf("%d\n", sizeof(union Un2));//16
	return 0;
}