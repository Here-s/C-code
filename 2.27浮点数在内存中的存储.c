#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

int main()// 浮点数存储的类型
{
	int n = 9;//存放的是补码  是1001 前面都是0
	float* pFloat = (float*)&n;
	printf("n的值为：%d\n", n);//9 
	printf("*pFloat的值为：%f\n", *pFloat);//E为全0  所以是   (-1)^0*0.00000000000000000001001*2^  -126  
	//因为只打印小数点后六位，所以是0.000000
	*pFloat = 9.0;//1001.0     (-1)^0*1.001*2^3   0 10000010 00100000000000000000000  
	printf("num的值为：%d\n", n);//1091567616
	printf("*pFloat的值为：%f\n", *pFloat);//
	return 0;
}


//指数E取出还有三种情况  不为全0，全1.指数E-127得到E的真实值 (-1)^0*1.011*2^2得到原来的数
//如果那8个值全为0 就意味着原来可能是负数 -127这样的数字  结果就是1-127  有效数字不+1
//如果那8个值全为1 e=128 表示正负无穷大的情况

//int main()
//{
//	float f = 5.5;//5.5    0.5转化为1    101.1    所以是(-1)^0*1.011*2^2  s=0 m=1.011 e=2    2+127=129    010000001 01100000000000000000000  32个比特位
//	//转换的16进制是 0x40b00000 
//	return 0;
//}

//根据国际标准IEEE（电气和电子工程协会）754，任意一个二进制浮点数V可以表示成下面的形式；
//(-1)^S*M*2^E
//(-1)^S表示符号位，当S=0，V为正数；当s=1，V为负数
//M表示有效数字，大于等于1，小于2.
//2^E表示指数位
//对于32位的浮点数 第一位是符号位S 接着8位是指数E 剩下的23位位有效数字M
//对于64位的浮点数 第一位是符号位S 接着11位是指数E 剩下的52位为有效数字M
//IEE754规定 计算机保存M时 默认这个数的第一位总是1 因此可以被舍去，只保存后面的xxxxxx部分  比如保存1.01 只保存01 读取的时候再把第一位的1加上去就行了
//这样做是为了节省有效数字

//整型变浮点型的时候，例如9.0 要把小数点两边都变成二进制位 1001.0    (-1)^0*1.001*2^3  s=0 m=1.001 e=3  根据上面说的 内存中存的是001

//int main()// 浮点数存储的类型
//{
//	int n = 9;//存放的是补码
//	float* pFloat = (float*)&n;//将n的地址强制转化成float*  pFloat作为一个指针
//	printf("n的值为：%d\n", n);//9 
//	printf("*pFloat的值为：%f\n", *pFloat);//浮点型打印的是0.000000  因为是浮点数拿的，说明浮点数的存储和取的方式和整型不一样
//	//整型和浮点型的存储形式不一样
//
//	*pFloat = 9.0;
//	printf("num的值为：%d\n", n);//1091567616   以浮点数放的  以整型拿的时候拿的是不一样的值
//	printf("*pFloat的值为：%f\n", *pFloat);// 以浮点数的形式放，浮点数的形式取就没问题。
//	//说明浮点数的存放和取出和整型的有区别
//	return 0;
//}

//int main()//浮点型在内存中的存储  类型有：float  double  lone double
////1E10表示1.0*10的十次方
//// float
//{
//	double d = 1E10;
//	printf("%lf\n",d);
//	return 0;
//}
