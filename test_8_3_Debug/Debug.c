#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>



//调试 当没有明确的报错之后，通过调试找到代码的错误
//调试的基本步骤
//1 发现程序错误的存在
//2 以隔离 消除等方式对错误进行定位    就是屏蔽掉一段没问题的代码 通过隔离一段代码查看问题
//3 确定错误产生的原因
//4 提出纠正错误的解决方法
//5 对程序错误予以改正，重新测试


//Debug 和 Release     
//Debug叫调试版本   是由程序员自己调试的
//Release叫发布版本   是给用户使用的 会做一些优化 使代码大小和运行速度上都是最优的
//在Release版本调试的时候 不能一步一步的调试  所以要使用Debug
//测试人员测的是 Release 版本 
int main()
{
	int arr[10] = { 0 };
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		arr[i] = 1;
	}
	for (i = 0; i < 10; i++)
	{
		printf("%d ", arr[i]);
	}
	return 0;
}


//vs当中 F5 是启动调试 但是如果不打断的话 就直接运行结束了 所以要和 F9 配合使用
//F9 就是产生断点 使 F5 运行到断点处 就直接跳到断点处了

//想要进入循环的哪个位置，就右击断点 设置条件为真 先 F10 调试 然后F5跳到断点，就到了条件断点了

//Ctrl+F 查找功能 也可以替换

//调试的时候  通过监视窗口查看局部变量的值是否正常变化  还可以通过自动窗口 局部变量查看
//监视窗口的话 可以随意观察变量



//函数调用堆栈   窗口里面可以找到  可以看栈区的使用情况
//void test2()
//{
//	printf("test2\n");
//}
//void test1()
//{
//	test2();
//}
//void test()
//{
//	test1();
//}
//int main()
//{
//	test();
//	return 0;
//}


//求 n 的阶乘
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	int ret = 1;
//	int sum = 0;
//	int i = 0;
//	for (i = 1; i <= n; i++)
//	{
//		ret *= i;
//		sum += ret;
//	}
//	printf("%d\n", sum);
//	return 0;
//}
//运行时错误的话 可以使用监视 查看变量的值是不是有问题


//int main()
//{
//	int i = 0;
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	for (i = 0; i <= 12; i++)//这里越界访问了 
//	{
//		arr[i] = 0;
//		printf("haha\n");//死循环了  因为arr[12] 的地址和 i 的地址一样了  
//		//因为刚开始开辟的空间只有10个  所以这里就把 i 改成0了 所以就一直死循环了
//		
//		//栈区的使用习惯是：先使用高地址 然后在使用低地址 所以先开辟 i 的空间 然后是 arr 的空间
//		//数组元素的地址是随着下标的增长，地址是由低到高变化 下标越高 地址越高 所以越界访问 
//		//访问的时候 就造成了把 i 修改成 0 了  这些是 Debug 版本下
//
//		//Release版本的话 就会优化这个 就不会死循环了
//	}
//	return 0;
//}


//编程常见型错误
//1 编译型错误 大多数都是语法错误 就是编译跑不过去 看报错原因就知道了
//2 链接错误 LNK （无法解析的外部符号 外部命令）  一般就是没有定义  找这个错误名字就好了
//  符号未定义 或者符号写错了
//3 运行时错误  运行期间发现结果错误  只能通过调试来解决 


//链接错误 因为未定义
//int main()
//{
//	int ret = Add(2, 3);
//	printf("%d\n", ret);
//	return 0;
//}