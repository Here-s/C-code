#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<string.h>


//算术操作符
//int main()
//{
//	//int ret = 9 / 2;
//	//printf("%d\n", ret);//是4 因为对于除号来说 两边都是整数 执行的是整数除法
//
//	//对于除号来说 操作数中有浮点数 才执行浮点数除法
//	//double ret = 9 / 2.0;
//	//printf("%.lf\n", ret);
//
//	//% 取模运算符  求得的是余数  只能针对整型 其他类型是不能取模的
//	int ret = 9 % 2;//当模2的时候 余数是不可能大于等于2的 只能是 0 1 
//	printf("%d\n", ret);
//	return 0;
//}


//移位操作符
//  << 左移操作符  左边丢弃 右边补零  左边不算符号位
//  >> 右移操作符   操作的是二进制位

//整数在内存中存储的是二进制的补码

//int main()
//{
//	int a = 5;
//	//00000101 写的是有效位 最高位是0 表示是正数 
//	//原反补都一样
//	int b = a << 1;//a向左移动一位 
//	//00000000000000000000000000000101    向左移动 
//	//00000000000000000000000000001010    就变成了10
//
//	//但是 a 的值是不变的
//	printf("%d\n", b);
//
//	int c = -1;
//	int d = c << 1;
//	printf("%d\n", d);//打印的是原码的值
//	//10000000000000000000000000000001    原码
//	//11111111111111111111111111111110    反码 符号位不变 其它位按位取反
//	//11111111111111111111111111111111    补码 反码+1
//
//	//11111111111111111111111111111111    -1补码
//	//11111111111111111111111111111110    左移的结果 也是补码  再 - 1取反就能得到原码
//	//11111111111111111111111111111101    左移之后的二进制补码 这个就是 -1 之后的
//	//10000000000000000000000000000010    再取反之后就是这个 输出就是-1
//
//
//	//对于整数的二进制位有三种表示形式：原码 反码 补码
//	//正整数：原码 反码 补码 相同
//	//负整数：
//	//原码：直接按照数字的正负写出的二进制序列  
//	//反码：原码的符号位不变 其他位按位取反 
//	//补码：反码+1
//	return 0;
//}

//右移操作符 >>
//右移操作符分为两种
//逻辑右移：右边丢弃 左边补0
//算术右移：右边丢弃 左边补符号位
//int main()
//{
//	int a = 5;
//	//00000000000000000000000000000101   
//	int b = a >> 1;
//	//00000000000000000000000000000010   使用算术右移就是这样 逻辑右移也一样 正数看不出来
//
//	int c = -1;
//
//	//11111111111111111111111111111111    内存当中放的是补码  右移 然后补符号位
//	//11111111111111111111111111111111    发现补了之后和-1 一样 所以当前编译器采用的是算术右移
//
//	int d = c >> 1;
//	printf("%d\n", b);
//	printf("%d\n", d);
//
//	return 0;
//}
//移位操作符必须是整型



//位操作符  
//  & 按位与      都是 1 结果才是 1
//  | 按位或   
//  ^ 按位异或
//int main()
//{
//	//int a = 3;       //%u 是无符号打印
//	//int b = -2;
//	//int c = a & b;//按的是二进制位位    是 2 
//	//00000000000000000000000000000011   3的补码
//	//10000000000000000000000000000010   -2的原码
//	//11111111111111111111111111111101   -2的反码
//	//11111111111111111111111111111110   -2的补码
//
//	//00000000000000000000000000000010   按位与的结果 
//
//	//int a = 3;
//	//int b = -2;
//	//int c = a | b;
//	//00000000000000000000000000000011
//	//11111111111111111111111111111110
//	//11111111111111111111111111111111   -按位或的结果 是补码  补码-1 取反得到原码
//	//10000000000000000000000000000001   //所以就是 -1 
//
//	//int a = 3;
//	//int b = -2;
//	//int c = a ^ b;//依然是按 二进制位进行异或  相同为 0  相异为 1 
//
//	//00000000000000000000000000000011
//	//11111111111111111111111111111110
//	//11111111111111111111111111111101   所以结果就是这样 是补码
//
//	//10000000000000000000000000000011   所以就是 -3 
//
//	//求 15 的二进制序列 有几个1  00001111  有四个 1
//	int a = 15;
//	//将它按位与一个 1 就能知道最低位有是几了 
//	a & 1;
//	a = a >> 1;//就相当于把最右边的一位去掉了 这样循环32次 就可以把二进制位 所有的 1 算出来
//
//	return 0;
//}


//一道面试题 不创建临时变量 对两个值进行交换
//int main()
//{
//	int a = 3;
//	int b = 5;
//
//	//a = a + b;
//	//b = a - b;//b放的是原来的 a 
//	//a = a - b;//这样就完成了交换  因为是整型变量 所以当数太大时 就可能会溢出
//
//	//printf("a=%d b=%d\n", a, b);
//	////还能用异或  但是只适用于整型
//	//a = a ^ b;
//	//b = a ^ b;
//	//a = a ^ b;
//	//printf("a=%d b=%d\n", a, b);
//
//	//0和任何数异或的结果还是任何数   异或是支持交换律的 所以上面还能写出	
//
//	return 0;
//}


//赋值操作符 = 

//int main()
//{
//	int a = 10;
//	int x = 0;
//	int y = 20;
//	a = x = y + 1;//先把 y + 1 的值赋给 x 然后 在把 值赋给 a 
//	printf("%d %d", a, x);
//	return 0;
//}


//int main()
//{
//	int a = 10;
//	a >>= 1;//就是 a = a >> 1;
//	return 0;
//}


//单目操作符  只有一个操作数

//int main()
//{
//	//int a = 5;
//	//int b = !a;//a放的是 5 是真 所以变为假 就是 0 
//
//	//如果把假变为真的话 就是 1 所有的非 0 都是真
//
//	int a = 10;
//	if (a)
//	{
//		printf("haha\n");//a为真 打印haha
//	}
//	
//	return 0;
//}


//正号
//int main()
//{
//	int a = 10;
//	a = -a;//就变成 -10 了
//	printf("%d\n", a);
//}


//能放在等号左边的叫左值  描述的是空间    a = 20 a就是左值
//能放在等号右边的叫右值  描述的是空间的内容  int b = a;//a 就是右值

//int main()
//{
//	int a = 10;
//	int* p = &a;//存放地址  *说明p是指针变量 存的a的地址 int*说明p指向的类型是整型
//	int b = *p;
//	*p = 20;//这里的 * 就是解引用操作符
//	printf("%d\n", a);
//	return 0;
//}


//数组也可以取地址


//sizeof 是操作符  是计算变量 或者类型创建变量的内存大小  只关注大小 不关注里面放的是什么

//int main()
//{
//	//char arr[10] = "abc";
//	//printf("%d\n", sizeof(arr));//算的是整个数组的大小
//	//printf("%d\n", strlen(arr));//算的是 '\0' 之前的字符个数
//
//	//int a = 10;
//	//printf("%d\n", sizeof(a));//4   因为算的是类型的大小
//	//printf("%d\n", sizeof(int));//4
//	
//	int a = 5;
//	short s = 10;
//	printf("%d\n", sizeof(s = a + 2));  //  2   因为还是短整型  所以是 2 
//	printf("%d\n", s);					//  10  因为sizeof内部的表达式 是不参与运算的
//	return 0;
//}


// ~ 就是按位取反 可以把符号位也按位取反
//int main()
//{
//	int a = 0;
//	//00000000000000000000000000000000
//	int b = ~a;//把所以二进制按位取反 符号位也要取反
//	//11111111111111111111111111111111    b的补码
//	//10000000000000000000000000000001    减一取反 得到原码
//	printf("%d\n", b);
//
//	return 0;
//}


//int main()
//{
//	int a = 13;
//	//00000000000000000000000000001101    把倒数第二位的 0 改为 1 
//	//只把倒数第二位按位或一个 0 就好了  1向左移动一位 然后按位或上去
//	a |= (1 << 1);
//
//	//在变回去 所以在按位与就行了 按位与原来的 ~a 
//	a &= (~(1 << 1));
//	printf("%d\n", a);
//	return 0;
//}


// ++  --  操作符
//int main()
//{
//	int a = 10;
//	//int b = a++;//这个是后置++  就是先使用a的值 然后a再+++
//	int b = ++a;//这个是前置++  是先++ 再使用   
//
//	// 前置-- 后置-- 也都一样
//
//	printf("%d\n", b);
//	printf("%d\n", a);
//	return 0;
//}


//强制类型转换
//int main()
//{
//	int a = (int)3.14;//默认写出的浮点数是 double 类型的  强制类型转化为整数  就是3
//	printf("%d\n", a);
//	return 0;
//}


//void test1(int arr[])
//{
//	printf("%d\n", sizeof(arr));//  是4 因为是指针  首元素地址是指针
//}
//void test2(char ch[])
//{
//	printf("%d\n", sizeof(ch));// 是4 因为是指针 
//}
//int main()
//{
//	int arr[10] = { 0 };
//	char ch[10] = { 0 };
//	printf("%d\n", sizeof(arr));// 是40 因为算的是整个数组的大小
//	printf("%d\n", sizeof(ch));// 是10 因为算的是整个数组的大小
//	test1(arr);
//	test2(ch);
//	return 0;
//}


//关系操作符 比较大小

//逻辑操作符 && 逻辑与  两边都为真 才为真
//逻辑或　||  逻辑或  两边有一个为真 就为真 两个都为假 才为假

//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a && b;//逻辑与操作符 只关注真假
//	printf("%d\n", c);//因为两个都为真 所以 c 为 1
//	return 0;
//}


//int main()//360面试题
//{
//    int i = 0, a = 0, b = 2, c = 3, d = 4;
//    i = a++ && ++b && d++;
//    printf("a = %d\n b = %d\n c = %d\nd = %d\n", a, b, c, d);//因为是 1 2 3 4 因为a等于0 所以判断为假
//    //判断为假 所以后面的东西就不执行了 所以a++ 所以就是 1 2 3 4 了
//    return 0;
//}


//三目操作符  表达式1？表达式2：表达式3   如果表达式1为真 就执行表达式2 否则执行表达式3
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int m = 0;
//	m = (a > b ? a : b);
//	printf("%d\n", m);
//	return 0;
//}


//逗号表达式  表达式从左到右计算 最后一个表达式是整个表达式的结果