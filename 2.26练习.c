#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<windows.h>



unsigned char i = 0;//范围是0-255
int main()
{
	for (i = 0; i <= 255; i++)//所以条件永远成立  写无符号数的生活，注意条件
	{
		printf("byte\n");//死循环 因为条件永远成立
	}
}

//int main()
//{
//	char a[1000];//数组下标是0-999
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;//char只能放-128到127  所以任何一个数放进来都会转化成  -128到127之间的数字  因为是一直往负走 所以是倒着那个圈圈走
//		//所以-129=127  就这样循环一直走 -1 .。。。-128 127.。。。3 2 1 0  最后是0 也就是\0  所以一共有128+127=255个字符
//	}
//	printf("%d", strlen(a));//strlen 求字符串长度  因为strlen找的是\0  \0的ASCII码值是0 所以最后找0就行了
//	return 0;
//}

//int main()
//{
//	unsigned int i;//因为是unsigned 所以i永远大于0，所以是死循环
//	for (i = 9; i >= 0; i--)//%u 是打印无符号十进制整数 
//	{
//		printf("%u\n", i);
//		Sleep(100);//意思是打印完休息0.1秒
//		//打印完是个超大数字 因为-1当成无符号数看的时候 就是一个超大数字
//	}
//	return 0;
//}

//int main()//用补码计算结果
//{
//	int i = -20;
//	unsigned int j = 10;
//	printf("%d\n", i + j);//拿补码算一下
//	//100000000000000000000000000010100  -20原码
//	//111111111111111111111111111101011  反码 符号位不变，其他位按位取反
//	//111111111111111111111111111101100  补码 反码+1得到补码
//	//000000000000000000000000000001010  10的原码 补码 反码  因为是无符号数 所以原反补相同
//	//111111111111111111111111111110110  加了之后的结果 这里是补码   因为是%d，所以算原码  
//	//100000000000000000000000000001010  补码-1取反得到原码  这里是-10
//	return 0;
//}

//int main()//下列数据输出什么
//{
//	char a = -128;//  128的话 也是这个结果 128=127+1  127+1就是-128了   参考那个圆形图
//	printf("%u\n", a);//%u 是打印无符号十进制整数   输出是4294967168
//	// -128  就是 100000000000000000000000000010000000  -原码
//	//char里面放的是 10000000  高位是符号位，所以前面加的全是1 提升之后全是补码 但是是%u 所以原反补相同 直接用这个就行了 所以是4294967168
//	//有符号的char 的表示范围是  -128到127    无符号的char的范围是0-255
//	return 0;
//}

//int main()//练习1:输出什么
//{
//	char a = -1;
//	signed char b = -1;
//	unsigned char c = -1;
//	//-1的补码全是1
//	printf("a=%d,b=%d,c=%d", a, b, c);//答案是 -1，-1，255
//	//a的话要整型提升 a是11111111，提升的时候补符号位 所以补的全是1 所以是倒回去原码是-1
//	//b跟a的情况一样
//	//c 是无符号数11111111，所以前面要补0，因为是无符号数，所以原反补都一样，所以原码也是这个 算出来是255
//	return 0;
//}