#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<windows.h>


//大小端存储   百度工程师面试题
//大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地
//址中；
//小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位, ，保存在内存的高地
//址中。

//int main()
//{
//	int a = 0x11223344;;//存顺序的是 44 33 22 11   11是高位字节
//	short b = 0x5566;//
//	return 0;
//}


//如何让写个代码告诉我们当前机器是打断还是小端
//给一个数据 a   0x00 00 00 01 第一个字节 打印出来是 01 就是小端存储  打印出是 00 就是大端
//整型是 4个字节  通过char* 来看待就可以拿到4个字节
//int check_sys()
//{
//	int a = 1;
//	return *(char*)&a;
//}
//int main()
//{
//
//	int ret = check_sys();//如果是大端 返回0   小端 返回1
//	if (ret == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//
//	//int a = 1;
//	//char* p = (char*)&a;
//	////对p 解引用 访问的就是 一个字节
//	//if (*p == 1)
//	//{
//	//	printf("小端存储\n");
//	//}
//	//else
//	//{
//	//	printf("大端存储\n");
//	//}
//	return 0;
//}


//代码输出的结果是什么
//int main()
//{
//    char a = -1;//这里是把 -1 放到 a 里面去了
//    //10000000000000000000000000000001      原码  
//    //11111111111111111111111111111110      反码
//    //11111111111111111111111111111111      补码
//    //因为是char 类型 所以发生截断   11111111
//
//    signed char b = -1;//表示有符号 
//    //11111111  也会发生截断
//    unsigned char c = -1;
//    //11111111  也会发生截断
//
//    //%d 以有符号整数的显示进行打印
//    printf("a=%d,b=%d,c=%d", a, b, c);//-1  -1  255  因为前两个都是有符号的  c是无符号 所以范围变大
//    //这里的打印 都是提升为整型 然后再提升  提升的时候 有符号数补的是符号位 然后再算出原码  所以a b 就是 -1
//    //c 是无符号整型 无符号数整型提升的时候 补的是 0 截断之后 8个位全是 1 所以是 255
//    return 0;
//}

//整型提升 按照符号位来提升 无符号数 高位补0  

//下列程序输出
//int main()
//{
//    char a = -128;//10000000000000000000000010000000     内存中存的是10000000
//    printf("%u\n", a);//%u 按无符号整型打印  4294967168   所以要整型提升 高位补的是符号位 因为不是无符号数
//    //11111111111111111111111110000000     %u 认为是无符号整型打印 所以这里就直接打印了
//    //char -128 ～ 127
//    return 0;
//}


//下列程序的运行结果
//int main()
//{
//    char a = 128;//char -128 ～ 127 当高于127之后 就是-128了  因为是一个圆盘的样子
//	  //00000000 00000001……01111111……10000001……11111110……11111111  从正数到了负数
//    printf("%u\n", a);//4294967168    因为是 -128 就变成了
//    //000000000000000000000000010000000
//
//    //10000000  -a 这就是128 进行整型提升
//    //111111111111111111111111110000000   补完符号位之后 因为是无符号数 所以值就是这个
//    return 0;
//}


//下列程序的运行结果
//int main()
//{
//	int i = -20;
//	unsigned  int  j = 10;
//	//10000000000000000000000000010100    -20的原码
//	//11111111111111111111111111101011    -20的反码
//	//11111111111111111111111111101100    -20的补码
//
//	//00000000000000000000000000001010    -10的原反补
//
//	//11111111111111111111111111110110    -直接两个数相加就好了 还是补码
//
//	//11111111111111111111111111110101    -反码
//	//10000000000000000000000000001010    -原码  就是-10
//	printf("%d\n", i + j);//不用管类型 还是拿补码计算 -10
//	return 0;
//}


//对于有符号整数的打印就应该是 %d 
//对于无符号整数的打印就应该用 %u


//下列程序的输出结果是
//int main()
//{
//	unsigned int n = -10;//-10 不关心 n 是什么类型 直接往里面放  放不下就截断
//	//1000000000000000000000000001010   负10 原码
//	//1111111111111111111111111110110   负10 补码
//	printf("%d\n", n);//-10
//	printf("%u\n", n);//4294967286  这个是无符号打印
//	return 0;
//}


//下列程序的输出结果
//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);//一直死循环 因为i 是无符号数 所以永远不会小于0 所以一直循环
//		//先打印 9 8 7 6 5 4 3 2 1 0   然后从4294967295开始打印 -1的无符号数就是4294967295 
//		Sleep(1000);//1000表示1秒
//	}
//	return 0;
//}


//下列程序的输出
//int main()
//{
//    char a[1000];
//    int i;
//    for (i = 0; i < 1000; i++)
//    {
//        a[i] = -1 - i;//arr就是 -1 -2 -3 -4……
//    }
//    printf("%d", strlen(a));//strlen 是找]0 也就是 0   这里是255  因为是从-1开始 -128下来是 127 126 
//    //所以最后就是255
//}


//二进制序列 00000000 00000001……01111111……10000001……11111110……11111111  从正数到了负数
//会一直轮回 计算那个圆圈模型


//下列程序的结果
//unsigned char i = 0;//范围 0-255
//int main()
//{
//    for (i = 0; i <= 255; i++)
//    {
//        printf("hello world\n");//死循环打印 因为无符号数 不会大于255 
//    }
//    return 0;
//}


//浮点型载内存当中的存储 1E10 表示1.0*1^10 这是科学计数法

//根据国际IEEE754标准 规定浮点数都可以表示成下面的形式：
//(-1) ^ S * M * 2 ^ E
//(-1) ^ s表示符号位，当s = 0，V为正数；当s = 1，V为负数。
//M表示有效数字，大于等于1，小于2。
//2 ^ E表示指数位。

//对于32位的浮点数 最高的1位是符号位S 接下来的8位是指数E 算下的23位为有效数字M

//对于64位的浮点数 最高的1位是符号位S 接下来的11位是指数E 算下的52位为有效数字M

//IEEE754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的
//xxxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目
//的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保
//存24位有效数字。、


//5.5 转化为 101.1  小数点后面的1是2的负1次方 负2次方   就是1.011*2^2 
//int main()
//{
//	int n = 9;//为 n 开辟空间
//	float* pFloat = (float*)&n;
//
//	printf("n的值%d\n", n);// 9 是以整数放的 再以整数拿出来 就没问题
//	printf("*pFloat的值%f\n", *pFloat);// 0.000000  以整型放的 以浮点数拿出来是这样 
//	//说明浮点数在内存中的存储和整型是不一样的
//
//	*pFloat = 9.0;
//	printf("n的值%d\n", n);// 1091567616
//	printf("*pFloat的值%f\n", *pFloat);// 9.000000
//	//又一次说明浮点数和整数在内存中的存储是不一样的
//	return 0;
//}


//int main()
//{
//	float f = 5.5f;
//	//101.1
//	//(-1)^0 * 1.011 *2^2
//	//S = 0;
//	//M = 1.011
//	//E = 2   +127 存储到第一个数0 后面
//	//0 10000001 01100000000000000000000  一共三部分 第一部分是S 正数是0   第二部分E+127  第三部分是小数点后面的
//	//0100 0000 10110000 0000000000000000   100写成16进制就是4  0000 就是0   1011 就是11 就是B   算下的转换为16进制就是00 00
//	//就是 40 B0 00 00   这就是存的方法
//
//	//取的方法 
//	//指数E 取出还分为三种情况 E不全为0 或不全为1     E全为0     E全为1
//	//E不为全0或不全为1 时 E的计算值减去127（或1023） 就得到真实值  再将有效数字M前加上第一位的1
//	// 
//	//E全为0  说明E 至少也是个-127  因为-127+127 = 0  说明这个数字是1.xxxxxxx * 2^-127  说明这是个非常小的数字
//	//     是非常接近于0   所以规定此时的指数E 对于1-127（或1-1023）就是真实值  M拿出来之后 也不在前面加 1 了
//	// 	   而是还原为 0.xxxxx的小数 这样做是为了表示 +-0  以及接近于0的很小的数字
//	// 
//	//E全为1   全是1 是255  -127 说明原来是128 就说明E是 1.xxx * 2^128   然后再加上正负  是一个非常大的数字
//	// 	   在加上正负 就是正负无穷大了
//	//
//	return 0;
//}


//所以 这样
int main()
{
	int n = 9;//二进制放的 是正数 原反补相同
	//00000000000000000000000000001001
	float* pFloat = (float*)&n;

	printf("n的值%d\n", n);// 整数存进去 整数取出来 所以没问题
	printf("*pFloat的值%f\n", *pFloat);//以浮点数打印 以为最高位的0 是符号位 接下来的8位是E 然后剩下的是有效位
	//取的时候发现E 就是0  就是1-127  就是 -126  M就是 0.0000000000000000001001
	// 	   M * 2^-126  数很小了 所以打印出来就是 0.000000

	*pFloat = 9.0;//以浮点数的形式存了 9.0
	//1001.0
	//(-1)^0 ^ 1.001 * 2^3
	//S = 0
	//E = 3
	//M = 1.001
	//0 10000010 00100000000000000000000
	printf("n的值%d\n", n);// 1091567616  因为是以整型打印 所以就是把上面的二进制位直接计算
	printf("*pFloat的值%f\n", *pFloat);// 9.000000    以浮点数放  浮点数去取 
	//
	return 0;
}