#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<string.h>
//#include"Add.h"//
//#pragma comment(lib,"add.lib")//这句话的意思就是导入静态库 


//函数的声明与定义
//int Add(int x, int y);//这里就是函数的声明    函数声明决定不了什么  声明这些东西一般都在头文件当中
//int main()//编译是从第一行从上往下扫描的 
//{
//	int a = 10;//这里就是通过工程来实现加法
//	int b = 20;
//	int ret = Add(a, b);//使用函数的时候 先声明 后使用
//
//	printf("%d\n",ret);
//	return 0;
//} 
//int Add(int x, int y)//这里就是函数体  也就是函数的定义 所以为了方便 就直接把函数写在main函数前面
//{
//	 return x + y;
//}


//分模块去写  
//1 就能多人协作了   
//计算器 ：总模块，加法，减法，乘法，除法。这样就能多个人协作了
//2 做到对源码的封装和隐藏   因为主函数里面只有声明 可以把Add.h  Add.c编译成一个静态库 就实现了对代码的隐藏
//静态库的使用 #pragma comment(lib,"静态库名称")   这样就完成了静态库的使用 



//函数递归 ：程序自己调用自己 就是递归 把一个大型问题层层转化为一个与原问题相似的规模较小的问题来求解
// 1  递归必须有限制条件     2  递归必须要逼近限制条件   在递归当中 尽量不要写前置 后置++
//因为前置 后置++ 就会导致递归错误
 
//void print(unsigned int n)//每一次函数调用 都要在内存当中开辟空间 
//{
//	//如果这个数 只剩一位数 那就直接打印出来就行了
//	if (n > 9)//这个条件必须有   假设无限制条件 就会无限递归 就会栈溢出 内存有栈区 堆区 静态区
//		//栈区：局部变量 形式参数   
//		//堆区：由程序员自己分配  malloc calloc realloc free
//		//静态区：全局变量 静态变量
//	{
//		print(n / 10);//123   这个限制条件也必须有
//	}
//	printf("%d ", n % 10);
//}
//int main()
//{
//	//接收一个整型值（无符号），安照顺序打印它的每一位
//	unsigned int num = 0;
//
//	//只要是函数调用 就会在栈上申请空间  main函数的栈上 除了局部变量剩下的空间 就叫函数栈帧（运行堆栈）
//	//所以num也在栈上  然后调用print函数 然后继续在栈上申请空间给print函数 
//
//	scanf("%d", &num);//1234 模10 余的就是4  1234除10 就得到了123   然后模10 就得到了3 以此往复就行了
//	//更好的方法就是用递归的方式  大事化小  函数自己调用自己  所以封装成函数的形式print
//	print(num);
//	return 0;
//}



//编写函数不允许创建临时变量 求字符串长度

//int my_strlen(char* s)//数组名arr是数组首元素的地址 所以用char* 来接收
//{
//	int count = 0;//这里也能求字符串长度 但是创建了临时变量 所以不符合题目要求
//	while (*s != '\0')//通过循环来求
//	{
//		count++;
//		s++;//指针++ 就是指针里面的地址++
//	}
//	return count;
//}

//int my_strlen(char* s)//用递归来解决这个问题   函数使用的时候 尽量不要使用全局变量
//{
//
//	//字符串是 
//
//	//大事化小  my_strlen("abcd")  所以就  1+my+strlen("bcd")   1+1+my_srelen("cd")   
//	//1+1+1+my_strlen("d")   1+1+1+1+my_strlen(" ")   1+1+1+1+0 = 4
//	if (*s != '\0')
//	{
//		return 1 + my_strlen(s+1);//s+1就是b的地址 因为如果是后置++的话 每次先使用 再++
//		//就是无限递归了每次递归都指向后一个元素
//	}
//	else
//	{
//		return 0;
//	}
//}
//int main()
//{
//	//求字符串长度
//	char arr[10] = "abcd";//这个数组的后三个空间都是0
//	//int len = strlen(arr);//从a开始数 到\0停止
//
//	//自己实现一个函数 my_strlen
//	int len = my_strlen(arr);//数组名arr是数组首元素的地址 所以用char* 来接收
//	printf("%d\n", len);
//	return 0;
//}


//涉及到指针+1 如果是字符指针 p+1就是向后跳一个字节 因为一个字符就是一个字节
//如果是一个整型指针，整型指针+1 就是向后跳四个字节   因为是指针 所以+1是跳到下一个元素


//递归常用在二叉树  由子类的都可以用递归 


//求n的阶乘
//int Fac(int a)
//{
//	int ret = 1;
//	int sum = 0;
//	for (int i = 1; i <= a; i++)
//	{
//		ret *= i;
//	}
//	return ret;
//}

//求n的阶乘 写成递归形式
//int Fac(a)
//{
//	if (a <= 1)
//	{
//		return 1;
//	}
//	else
//	{
//		return a * Fac(a - 1);
//	}
//}
//int main()
//{
//	int a = 0;
//	scanf("%d", &a);
//	int ret = Fac(a);
//	printf("%d\n", ret);
//	return 0;
//}


//递归求斐波那契数列   求第n个斐波那契数
//不适合用递归来算  因为第50个就会产生49 48 然后继续递归产生数据  所以会重复计算 浪费大量时间


//int Fib(n)//但是递归会 递下去 归上来  所以会浪费时间 进而可以考虑用循环来算
//{
//	if (n <= 2)
//	{
//		return 1;
//	}
//	else
//	{
//		return Fib(n - 1) + Fib(n - 2);
//	}
//}

//用循环来计算
//int Fib(n)
//{
//	int a = 1;
//	int b = 1;
//	int c = 1;//C一定要等于1 因为如果进不来循环的话，就说明是1 所以把C返回就行了
//	while (n > 2)//通过迭代(循环)的方式 效率就会提升很多
//	{
//		c = a + b;
//		a = b;
//		b = c;
//		n--;
//	}
//	return c;
//}
//int main()
//{
//	int fib = 0;
//	scanf("%d", &fib);
//	int ret = Fib(fib);
//	printf("%d\n", ret);
//	return 0;
//}


//什么时候用递归
//1 当解决一个问题递归和非递归都可以使用，且递归没有明显问题，那就可以使用递归。
//2 当解决一个问题递归写起来很简单，非递归比较复杂，且递归没有明显问题，那就可以使用递归。
//3 如果说用递归解决问题，写起来简单，但是有明显问题，那就不能使用递归。
//递归不能解决问题的话，非递归再难也要写 

//如果在递归当中要创建局部变量的话 每次递归都会重新创建，所以建议创建成全局变量 
//因为不会重复创建 就能节省空间了