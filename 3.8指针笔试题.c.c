#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>




int main()
{
	int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 };//这里存放的情况是每行5个元素   但实际是1行 这样方便理解计算
	int* ptr1 = (int*)(&aa + 1);//数组指针类型
	int* ptr2 = (int*)(*(aa + 1));//(*(aa + 1))等价于aa[1] 表示的是第二行首元素的地址 就是6的地址 然后转化为int* 
	printf("%d,%d", *(ptr1 - 1), *(ptr2 - 1));//10 5 
	return 0;
}

//int main()
//{
//	int a[5][5];
//	int(*p)[4];//p是指针 指向的是 数组 每个元素是整型 指向四个整型元素的指针  这里用到数组指针
//	//p[4][2];的意思是*(p+4) +2就是*(*(p+4)+2)  相当于拿到的是a[3][3]  指针-指针得到的是指针和指针之间的元素个数 所以是-4
//	p = a;//a的类型是这样int(*)[5]  p的类型是int(*)[5]  这里是将a的值强行赋给b 但实际还是指向最开始 每次p[]改变 就移动四个字节
//	printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);//-4 但是那%p打印的是内存中的值是无符号的 是补码
//	//补码就是最后两个是0 其他的全是1 四个1是一个f 最后剩下一个12 12就是c 所以是FFFFFFFC
//	return 0;
//}

//int main()
//{
//	int a[3][2] = { (0,1),(2,3),(4,5) };//括号里面是逗号表达式，结果是最后一个结果 所以算的就是{1，3，5} 所以是放的1，3，5 最后面几个默认填充0
//	int* p;
//	p = a[0];//代表的是首元素地址-首行 首元素
//	printf("%d\n", p[0]);//1  因为p[0]代表的是*（p+0） 所以是1
//}

//int main()
//{
//	int a[4] = { 1,2,3,4 };//数组a 有4个元素
//	int* ptr1 = (int*)(&a + 1);//因为是取地址+1 所以是跳过数组a 所以ptr1指向的就是这个数组地址最后的新的地址
//	int* ptr2 = (int*)((int)a + 1);//1的地址强制转换位整数 +1就是向后移动了一个字节 地址+了1 所以ptr2就指向了1的第二个字节 1一共有4个字节
//	//%x 打印16进制
//	printf("%x,%x", ptr1[-1], *ptr2);//4 2  ptr1[-1]就是向前挪一个整型 所以是4   *ptr2解引用向后访问四个字节 以小端的形式拿出来 所以是0x02 00 00 00
//	return 0;
//}

//struct Test
//{
//	int Num;
//	char* pcName;
//	short sDate;
//	char cha[2];
//	short sBa[4];
//}*p;//结构体指针变量p
////假设p的值是0x100000.如下表达式的值分别是多少？
////已知结构体test类型的变量大小是20个字节
//int main()//+几是取决于指针类型
//{
//	p =(struct Test*) 0x100000;//强制类型转换过去 然后使用  +几是取决于指针类型
//	printf("%p\n", p + 0x1);//%p 打印地址 00100014  p+1 加多少取决于指针类型 所以是跳过一个结构体 20个字节 20的16进制是14
//	printf("%p\n", (unsigned long)p + 0x1);//00100001  将p强制转化成整数 100000转化成10进制是1048576 所以+1就是单纯的+1 1048577 再转回去是加了1 所以是00100001
//	printf("%p\n", (unsigned int*)p + 0x1);//00100004  将p转化成无符号的整型指针 所以+1要跳过一个无符号整型 所以是+4 所以就是00100004
//	return 0;
//}

//写代码三种境界
//1 看代码是代码
//2 看代码是内存
//3 看代码是代码
//int main()
//{
//	int a[5] = { 1,2,3,4,5 };//数组内部放的是1，2，3，4，5  
//	int* ptr = (int*)(&a + 1);//数组的地址取出来 +1就是跳过这个数组 地址是数组指针类型 所以强制类型转换为int* 存进ptr里面  所以向后-1就是指向5
//	printf("%d,%d", *(a + 1), *(ptr - 1));//2 5  因为a是首元素地址 +1就是第二个元素 所以解引用就是2 
//	return 0;
//}