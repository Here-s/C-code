#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

//操作符
//1 算术操作符 +  -  *  /  %(取模 就是取余数)
//int main()
//{
//	//int a = 7 / 2;
//	//int b = 7 % 2;
//	//printf("%d\n", a);//结果是3 因为除号两端都是整数 所以得到的也是整数 就是3
//	//printf("%d\n", b);//结果是1 这里得到是余数 
//	float f = 7 / 2.0;//只要有一个小数就能求得小数了
//	printf("%f\n", f);
//	return 0;
//}

//移位操作符 >>  <<
//int main()
//{
//	int a = 12;
//	int b = a << 1;//把a向左移动一位  移动的是二进制位  12的二进制序列是 0000 1100 这是后八位 
//	//所以左移一位就是0001 1000 就是24
//	//一个二进制位有32位 
//	printf("%d\n", b);
//	return 0;
//}

//位操作符  & | ^  分别是按位与 按位或 按位异或
//int main()
//{
//	int a = 3;
//	int b = 5;
//	//int c = a & b;//3的二进制序列最后四位 0011    5的二进制序列最后四位0101   按位与：两个为1 才为1   所以结果是0001
//	//printf("%d\n", c);//结果是1  
//	//int c = a | b;//按位或 有一个1 结果就是1  就是0011 和0101 按位或 所以结果就是0111  就是7
//	//printf("%d\n", c);//
//	int c = a ^ b;//按位异或 二进制为相同为0 不相同为1  所以0011 和0101异或  所以就是0110  就是6
//	printf("%d\n", c);
//	//按位与： 对应的二进制位 有0则为0 两个同时为1 才是1
//	//按位或： 对应的二进制位 有1则为1 两个同时为0 才是0
//	//按位异或  对应的二进制位 相同为0 不相同为1
//	return 0;
//}

//一个等号就是赋值操作符
//int main()
//{
//	float score = 0;
//	score = 95.4;//直接写出的浮点数默认是double类型的 在95.4之后加上f就是float类型了
//	int a = 10;
//	a = a + 5;
//	a += 5;//和a = a + 5 是一样的 +=   *=  -=  这些都是复合操作符
//	return 0;
//}

//int main()
//{
//	//3 + 5;//+是操作符  3  5 是操作数  3是左操作数   5是右操作数    +两边有两个操作数  所以+就是双目操作符
//	int flag = 5;
//	//C语言表示真假  0就是表示假  非0就是真
//	if (flag)
//	{
//		printf("hh\n");//当flag为真的时候 就打印hh 所以只有flag为0的时候 才不打印hh
//	}
//	//！逻辑反操作
//	flag = 0;
//	int b = !flag;
//	printf("%d\n", b);//是1  因为规定出来0的逻辑反操作是1
//	//+ 是不会让负数变为正数的
//	//sizeof是操作符  操作符就是运算符    sizeof只关心内存大小不关注有什么    strlen是关注空间里面有什么
//	return 0;
//}

//整数的二进制表示方式有三种 原码 反码 补码
//原码： 直接按照数字的正负转换成二进制就是原码
//反码： 符号位不变 原码按位取反就行了
//补码： 反码+1 就是补码

//规定： 正整数的  原码 反码 补码 相同    
//负数的 原码 反码 补码 要计算   

//规定： 对于有符号整数 二进制的最高位是符号位
//最高位是0 表示正数   最高位是1 表示负数

// ~(按位取反) 对二进制位就行按位取反 
//就是把0变成1 把1变成0 
//int main()
//{
//	int a = 0;
//	printf("%d", ~a);//结果是-1  因为按位取反之后的二进制位全是1 二进制位的第一位是符号位 第一位是1的话 结果是-1
//	//-1的原码就是100000000...00001   取反得到反码 11111111...1110   +1得到补码 111111111...11111
//	//整数在内存中存放的是二进制的补码
//
//	//原来是补码 取反之后还是补码
//	return 0;
//}

//int main()
//{
//	//++ -- 操作符
//	int a = 10;
//	//int b = a++;//后置++  先使用 再++(就是加1)   
//	int b = ++a;
//	printf("%d\n", a);
//	printf("%d\n", b);
//	return 0;
//}

//强制类型转换
//int main()
//{
//	int a = (int)3.14;//想把3.14赋给a  强制类型转换  强制将double的3.14强制转化为int
//	printf("%d\n", a);
//	return 0;
//}

//比较关系操作符
//int main()
//{
//	int a = (3 > 5);
//	printf("%d\n", a);//因为表达式3>5为假 所以 把假赋给a a就是0
//	return 0;
//}

//逻辑操作符
//&& ||  分别是逻辑与  逻辑或
//int main()
//{
//	//假设法定结婚年龄
//	//男：22  A
//	//女：20  B
//	//A B   要结婚的话 A要大于等于22岁   并且B要大于等于20岁
//	int a = 25;
//	int b = 19;
//	if ((a >= 22) && (b >= 20))//&& 逻辑与  两边同时为真才为真
//	{
//		printf("允许结婚\n");
//	}
//	// || 逻辑或  只要满足几个条件中的一个就行了 两边有一个为真就行了
//
//	return 0;
//}

//条件操作符    三目操作符 exp1? exp2: exp3  如果exp1表达式为真 就执行exp2  exp为假 就执行exp2
//int main()
//{
//	int a = 10;
//	int b = 20;
//	//求出a和b的较大值
//	int max = 0;
//	//if (a > b)
//	//{
//	//	max = a;
//	//}
//	//else
//	//{
//	//	max = b;
//	//}
//	//用条件操作符
//	max = (a > b) ? a : b;
//	printf("%d\n", max);
//	return 0;
//}

//逗号表达式   exp1,exp2,exp3...expn   用逗号将多个表达式隔开    从左向右依次计算  整个表达式的结果是最后一个表达式的结果
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = 6;
//	int d = (a -= 2, b = a + c, c = a - b);
//	printf("%d\n", d);//-6 因为表达式的结果是最后一个表达式的结果
//	return 0;
//}

//操作符 [] ()  分别是下标引用操作符和函数调用操作符   ()是函数调用是传参用
//int Add(int x, int y)//int表示函数调用之后的返回值
//{
//	int z = x + y;
//	return z;
//}
//int main()//main函数也是被调用的
//{
//	//int arr[10] = { 1,2,3,4,5,6 };
//	//arr[4];//这个[] 就是下标引用操作符    []的操作数是arr  4 
//	int a = 10;
//	int b = 20;
//	int sum = Add(a, b);//这是一次函数调用   () 的操作数是Add a b  也可以不传参
//	printf("%d\n", sum);
//	return 0;
//}

//关键字   不能自己创建   自己定义的变量名不能是关键字
//int float while return  这些都是C语言规定的关键字
//break 用于循环  switch  
//case 用于switch语句  也是分支
//continue 用于循环
//default  默认选项 也是用于switch  
//extern  用来声明函数
//goto   可以用于循环  也可以用于分支
//register  寄存器
//return    返回关键字
//signed   有符号 
//static  静态关键字
//struct  自定义类型
//typedef  类型重定义  类型定义
//union   联合体关键字
//unsigned   无符号数
//volatile    Linux系统部分

//typedef 关键字
//typedef unsigned int uint;//对unsigned int 重定义为uint   是对类型重命名
//int main()
//{
//	int a = 10;//这就是个aotu类型
//	unsigned int age;//定义一个无符号的整型
//	uint age2 = 20;//通过typedef定义unsigned int 为 uint
//	return 0;
//}

//static 关键字
//static 有三种用法  1 static修饰局部变量   2 static修饰全局变量   3 static修饰函数
//void test()
//{
//	static int a = 1;
//	a++;
//	printf("%d\n", a);//不加static的话 每次都是2  因为每次的a都会销毁  
//	//如果加上static的话(使得局部变量出了自己的范围也不销毁 延长局部变量的生命周期) 函数调用结束后 a就不会被销毁 
//	//但是作用域还是局部的 作用域没变
//}
//int main()
//{
//	int i = 0;
//	while (i < 10)
//	{
//		test();
//		i++;
//	}
//	return 0;
//}

//static修饰全局变量
//全局变量不加static的话  是具有外部链接属性的  
//但是 static修饰全局变量之后 会使全局变量失去外部连接属性 变成内部连接属性 
//所以static修饰的全局变量只能在自己所在的.c文件中使用

//声明外部的变量 就是另外一个源文件 通过extern关键字来声明  另外一个源文件里面的全局变量
//extern int ext;
//int main()
//{
//	printf("%d\n", ext);//通过extern声明 来访问另外一个源文件  最后会汇编生成一个文件 
//  //如果另外一个源文件里面的全局变量前面加了static 在这里声明之后 依然不能访问这个全局变量
//	return 0;
//}

//static修饰函数
//如果static修饰另外一个源文件的Add函数的话  这里声明之后也不能使用了  和函数一样
//函数默认是具有外部连接属性的  当加上static之后 就使得函数失去有外部链接 变成内部连接属性
//static修饰的函数只能在自己所在的.c文件没部使用 不能在其它文件使用
extern int Add(int x, int y);//声明来自外部的函数
int main()
{
	int a = 10;
	int b = 20;
	int ret = Add(a, b);
	printf("%d\n", ret);
	return 0;
}