#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<string.h>


//一维数组
//一维数组的创建和初始化   数组就是一类相同元素的集合   
//创建数组的时候 即不初始化 也不指定大小的话 是不行的
//int arr7[];//全局数组不初始化的话，就会全部初始化为0
//int main()
//{
//	int arr[20] = { 0 };//将数组初始化为 0  []里面用常量
//	int arr2[] = { 1,2,3 };//将arr2 初始化为3个元素 元素是 1 2 3  
//	int arr3[3] = { 4,5,6 };//设定数组的大小是3个元素 
//	char arr4[] = "abc";//这里是3个字节 有\0
//	char arr5[] = { 'a','b','c' };//这里不包括\0
//	char arr6[] = { 'a',98,'c' };//是字符数组，所以就会把 98 转化为某个字符 
//	//把98当作某个字符的ASCII码值
//	return 0;
//}


//数组是通过下标来访问的  数组名[下标]
//int main()
//{
//	//结构体也可以创建数组
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
//	printf("%d\n", arr[4]);//通过下标打印5
//	int i = 0;
//	//计算数组元素个数
//	int sz = sizeof(arr) / sizeof(arr[0]);//这样的话 数组大小就一直可以计算出来了
//	for (i = 0; i < sz; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	return 0;
//}


//一维数组在内存中的存储
//int main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	for (i = 0; i < sz; i++)
//	{
//		printf("%p\n", &arr[i]);//%p 打印地址 发现地址是连续的 所以数组在内存当中是连续存储的
//		//数组随着下标的增长，地址是由低地址到高地址变化的
//	}
//	return 0;
//}


//二维数组
//二维数组的创建 
//int main()
//{
//	//int arr[3][5];//这个数组是三行五列
//	//char ch[4][6];//这个char类型的数组是四行六列
//	int arr[3][5] = { 1,2,3,4,5,6,7,8,9,10,11 };//存放是先放满一行之后再放第二行 
//	//当没元素放的时候 剩下的默认初始化为0
//	int arr2[3][5] = { {1,2},{3,4},{5,6} };//这里是把三行 每行都放了两个元素 将数据固定初始化到某一行
//	int arr3[][5] = { {1,2},{3,4},{5,6} };//二维数组的行可以省略 列不能省略
//	//int arr4[][5];//如果不初始化的话 二维数组不能省略行
//	char ch[4][6] = { 'a','b' };//一个一个的放元素
//	char ch2[4][6] = { {'a'},{'b'} };//把 a 和 b 放在两行 每行一个元素
//	char ch3[4][6] = { "abc","def","qwe" };//这里也是占了三行  因为二维数组的每行可以看成一维数组
//	//就相当于每行的一维数组放的是一个字符串
//
//	//规定二维数组的行和列都是从 0 开始  通过下标就能好好的访问
//	return 0;
//}



//二维数组的访问
//int main()
//{
//	int arr[3][5] = { {1,2,3},{4,5,6},{7,8,9} };
//	int i = 0;
//	//for (i = 0; i < 3; i++)
//	//{
//	//	int j = 0;
//	//	for (j = 0; j < 3; j++)
//	//	{
//	//		printf("%d ", arr[i][j]);
//	//	}
//	//	printf("\n");
//	//}
//
//	for (i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for (j = 0; j < 3; j++)
//		{
//			printf("%p\n", &arr[i][j]);//%p 打印地址
//		}
//		printf("\n");
//	}
//	//通过打印地址发现  二维数组在内存当中也是连续存储的  就是连续的空间
//	//对二维数组来说 不省略列 是因为内存中连续存储 所以只有知道列的时候 才能放下一行元素
//
//	return 0;
//}


//
//int main()
//{
//	int arr[5] = { 1,2,3,4,5 };
//	//printf("%p\n", arr);
//	//printf("%p\n", &arr[0]);//发现打印的值一样  说明数组名就是数组首元素的地址
//	int* p = arr;
//	int i = 0;
//	for (i = 0; i < 5; i++)
//	{
//		printf("%d ", *p);
//		p++;//指向下一个地址  因为数组在内存当中是连续存放的  所以可以拿指针来访问
//	}
//	printf("\n");
//	for (i = 0; i < 5; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	return 0;
//}


//int main()
//{
//	int arr[3][5] = { {1,2,3},{4,5,6},{7,8,9} };
//	int* p = &arr[0][0];
//	int i = 0;
//	for (i = 0; i < 15; i++)
//	{
//		printf("%d ", *p);
//		*p++;//因为二维数组在内存当中也是连续存放的  所以也可以指针++ 来指向下一个元素
//	}
//	return 0;
//}


//数组越界  当一个数组提供了大小之后 就固定了下标 如果超了这些下标 就是越界访问
//int main()
//{
//	int arr[5] = { 1,2,3,4,5 };
//	int i = 0;
//	for (i = 0; i <= 5; i++)
//	{
//		printf("%d ", arr[i]);//arr[5] 就越界了所以打印出来的是随机值
//		//因为C语言本来是不做数组越界检查的  所以编译器也不报错 
//	}
//	return 0;
//}


//int main()
//{
//	int arr[5] = { 1,2,3,4,5 };
//	int i = 0;
//	for (i = 0; i <= 5; i++)
//	{
//		arr[i] = 0;//这样就会报错  因为对越界的地方进行了修改
//	}
//	return 0;
//}



//数组可以作为函数参数
//void Sort(int arr[],int sz)//因为是传的数组 所以拿数组来接收就没问题   这里写成void Sort(int* arr) 更好
////排序方法有 ： 冒泡 选择 插入 快速排序
//{
//	//冒泡排序的核心思想：两两相邻的元素进行比较 如果不满足顺序的话 就把他们的顺序进行修改
//	//一趟冒泡排序能搞定一个数字 就是可以把一个数组来到最终的位置 
//	//所以一趟可以处理一个元素 所以10个元素的话 最多进行9趟冒泡排序 因为9个元素都排好了 那么最后一个也好了
//
//	//因为传的是指针 32位平台的指针是四个字节 整型也是4个字节 所以 sz 就是1 
//
//	//int sz = sizeof(arr) / sizeof(arr[0]);//因为是指针 所以就不能这样计算了 在函数内部就不能这也算了
//	//所以在函数外部算
//	
//	//所以进行sz-1趟冒泡排序就行了
//	int i = 0;
//	for (i = 0; i < sz - 1; i++)
//	{
//		int flag = 1;
//		//如果有10个元素  就比较9对元素 第二趟就是8个元素 每趟比较对数-1
//		int j = 0;
//		for (j = 0; j <sz-1-i ; j++)//因为每趟的比较次数都少一 所以每次-i 就好了
//		{
//			if (arr[j] > arr[j + 1])
//			{
//				//交换
//				int tmp = arr[j];
//				arr[j] = arr[j + 1];
//				arr[j + 1] = tmp;
//				flag = 0;
//			}
//		}
//		if (flag == 1)
//		{
//			break;//跳出排序循环 
//		}
//	}
//}
////不论是什么类型的指针 在32位平台下面都是 4个字节
//void print(int* arr,int sz)
//{
//	int i = 0;
//	for (i = 0; i < sz; i++)
//	{
//		printf("%d ", *arr);//写成arr[i] 也没问题  或者*(p+i)
//		*arr++;
//	}
//}
//int main()
//{
//	int arr[] = { 1,4,2,3,8,7,5,6,9,0 };
//
//	//数组名单独放在 sizeof 内部的话 代表整个数组  不是首元素的大小
//
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	//对数组进行排序  所以要把arr传给Sort函数  数组传参
//
//	//数组名在传递给函数的时候 会降级变成首元素地址
//	Sort(arr, sz);//数组名就是首元素地址 所以传参的时候就是把首元素地址传过去了
//	print(arr, sz);//用函数来打印数组
//	return 0;
//}



//数组名是什么
//绝大多数情况下：数组名就是首元素的地址
//有两个意外 
//1. sizeof(数组名) 这里的数组名表示整个数组，sizeof(数组名) 计算的是某个数组的大小
//2. &数组名 这里的数组名表示整个数组  取出的是数组的地址

//int main()
//{
//	int arr[10] = { 1,2,3,4,5 };
//	printf("%p\n", arr);
//	printf("%p\n", &arr[0]);//数组名就是首元素地址
//	printf("%p\n", &arr);//数组的地址   和上面两个的值一样  但是意义不一样 
//
//	printf("------------------\n");
//	printf("%p\n", arr)+1;
//	printf("%p\n", &arr[0]+1);//和上面的+1 一样 表示第二个元素的地址
//	printf("%p\n", &arr+1);//这里的+1 和不+1 差40个字节 因为数组是10个元素 所以是40个字节
//	//数组地址+1 就是指向这个数组最后一个元素的地址的下一个地址  数组的地址是影响整个数组
//
//	return 0;
//}