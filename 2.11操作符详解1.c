#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>;


//int main()//按位异或
//{
//	int a = 3;
//	int b = 5;
//	int c = a ^ b;//二进制序列 相同为0 相异为1
//	printf("%d\n", c);
//
//
//	return 0;
//}

//int main()//按位或
//{
//	int a = 3;
//	int b = 5;
//	int c = a | b;//|按位或的意思，有一个1 结果就是1
//	printf("%d\n", c);
//	return 0;
//}

//int main()//位操作符
//{
//	int a = 3;//& 按二进制位与
//	int b = 5;
//	int c = a & b;//a按位与b  a 011   b 101  对应的二进制位 一个为0 则为0  两个为1 才能为1  所以结果是001
//	printf("%d\n", c);
//	return 0;
//}

//int main()
//{
//	int a = 5;
//	int b=a << 1;
//	//左移操作符 左边丢弃 右边补零
//	printf("%d\n", b);
//	return 0;
//}

//int main()  //移位操作符 只能作用于整数
//{
//	int a = 16;
//	a >> 1;//右移操作符  移动的是二进制位  16=0000000000000000000000000000010000  32个比特位
//	int b = a >> 1;//a右移一位然后将值赋给b
//	//算术右移：右边丢弃 左边补原符号位 比如最右边原来是1  那边左边也是补1
//	//逻辑右移：右边丢弃 左边补零
//	//编译器采用的是算术移位
//	//如果a是-1的话  二进制表示有原码 反码 补码  内存存的是补码 移位移的也是补码
//	//例如1000000000000000000000000000001   第一个1是负 最后一个是1 所以是-1 这里是原码  第一位不变其他位取反 得到的就是反码  反码+1得到补码
//	printf("%d", b);
//	return 0;
//}

//int main()
//{
//	//int a = 5 / 2;//除法算出的是商2余1  因为是整数所以结果是2
//	//double a= 5 / 2.0;//这样打印出的就是有小数的  因为2加了小数点  打印浮点型 lf    要想变成小数  至少有一个浮点型
//	//double a = 5 % 2;//模的时候必须是整数
//	printf("a=%lf\n", a);
//	return 0;
//}