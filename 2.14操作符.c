#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

//我们写的代码应该通过 操作符的优先级  操作符的结合性  是否控制求值顺序 就能确定一个唯一的计算路径

int main()
{
	int i = 1;
	int a = (++i) + (++i)+(++i);
	printf("a=%d\n", a);//不同平台算出来的不一样  因为计算顺序不一样 华而不实的代码
	return 0;
}

//写代码要确定求值路径是唯一的
//int fun()//问题代码4
//{
//	static int count = 1;//因为有static 所以这次的值不销毁 下次循环开始是这次结束的值  
//	return ++count;
//}
//int main()
//{
//	int answer;
//	answer = fun() - fun() * fun();//有问题 算的时候哪个fun先调用 不确定 所以有问题  因为调用顺序有问题 所以返回结果也不同 所以代码有问题
//	printf("%d\n", answer);//输出多少
//	return 0;
//}

//int main()//非法表达式   因为计算顺序不一样 不同编译器的结果不一样 所以是非法表达式 计算路径不确定
//{
//	int i = 10;
//	i = i-- - --i * (i = -3) * i++ + ++i;
//	printf("i=%d\n", i);
//	return 0;
//}

//问题表达式2
// c+ --c;  --先算  --优先级高  假设c=1 所以是1+0   而先算--c是0 右边也变成0 那究竟哪个对 所以还是问题表达式

//表达式的求值有三个影响因素 1 操作符的优先级  2 操作符的结合性（有从左到右的方式 有从右到左的方式） 3 是否控制求值顺序
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int c = b + a * 3;//优先级不同 先算* 再算+
//	// 问题表达式 a*b+c*d+e*f 因为有多种算法都可以 但是结果不一样所以 是问题表达式
//	return 0;
//}

//int main()//算术转换 也是一种类型转换
//{
//
//	return 0;
//}

//int main()//整型提升实例2
//{
//	char c = 1;
//	printf("%u\n", sizeof(c));//char 是一个变量 一个字符 所以这里是1
//	printf("%u\n", sizeof(+c));//这里进行运算了 所以最后算的是整型 是4个字节
//	printf("%u\n", sizeof(!c));//没计算 所以是1 同第一个
//	//结果是1 4 1
//	return 0;
//}

//int main()//整型提升实例1
//{
//	char a = 0xb6;
//	short b = 0xb600;
//	int c = 0xb6000000;
//	if (a == 0xb6)
//		printf("a");
//	if (b == 0xb6000)
//		printf("b");
//	if (c == 0xb6000000)
//		printf("c");
//	//只打印了c 因为a是个char b是short  也会整型提升  提升之后肯定不一样 所以不打印  c本来就是整型 所以会打印c
//	return 0;
//}

//int main()//表达式求值  顺序是由操作符的优先级和结合性决定  有些操作符需要类型的转换
////隐式类型转换   整型提升
////如果是无符号数的话直接补0
//{
//	//char a, b, c;
//	//a = b + c;//计算时b和c要被提升为普通整型  然后在进行加法运算  算后的结果要截断 然后放到a里面
//	char a = 3;//a只能放一个字节 八个比特位 所以有截断  所以是00000011 
//	char b = 127;//b只能放一个字节 八个比特位 所以有截断  所以是01111111
//	//a和b 如何相加  因为a和b的类型都是char类型 大小没达到整型的大小 计算的时候为了提升计算精度 所以要转化为普通整型 也就是整型提升 然后再计算
//	//整型提升是按照变量的数据类型的符号位来提升的
//	//因为a是有符号的所以把最高位认为符号位00000011 第一个0就是符号位 提升的时候高位通通补0    b也是一样 所以加完之后是 10000010 前面都是0 
//	//加完之后放到c里面  c还要截断 所以c是10000010  因为打印的是整型 所以要整型提升 高位是符号位 所以前面补的全是1 补完的全是补码
//	//补码-1取反得到原码  补码-1得到反码  所以c是100000000000000000000000001111110  因为第一个是1 所以是- 所以结果是 -126
//	char c = a + b;
//	//
//	printf("%d\n", c);
//	return 0;
//}

//struct Stu//学生类型  这里是创建了一个结构体类型-struct Stu
//{
//	//描述对象所需的成员变量
//	char name[20];
//	int age;
//	char id[20];
//};
//int main()//结构成员   -> 结构体指针操作符    左边是结构体指针  右边是成员名  
//{
//	int a = 10;
//	//使用struct Stu 这个类型创建了一个学术对象s1  并且初始化
//	struct Stu s1 = {"Here",20,"200805031122"};
//	struct Stu* ps = &s1;
//	printf("%s\n", ps->name);//ps是指针 指向的对象是name
//	printf("%d\n", ps->age);
//	printf("%s\n", ps->id);
//	//struct Stu* ps=&s1;//ps是指针变量  指针类型是struct Stu  这样有点嗦 有更好的方法在上面
//	//printf("%s\n", (*ps).name);
//	//printf("%d\n", (*ps).age);
//	//printf("%s\n", (*ps).id);
//	//printf("%s\n", s1.name);//%s是打印名字
//	//printf("%d\n", s1.age);
//	//printf("%s\n", s1.id);
//	//结构体变量.成员名.
//	return 0;
//}

//int get_max(int x, int y)//get_max的两个参数
//{
//	return x > y ? x : y;
//}
//int main()
//{//函数调用操作符
//	int a = 10;
//	int b = 20;
//	int max=get_max(a, b);//调用函数的时候的（）就是函数的调用操作符   必须要有一个操作数
//	printf("max=%d\n", max);
//	return 0;
//}

//int main()//下标引用 函数调用 结构成员  三个操作符
//{//[]下标引用操作符
//	int a[10] = { 0 };
//	a[4] = 10;//[]它的操作数是a 和4    只要是操作符就有操作数
//	1 + 2;//1 2  就是+号的两个操作数
//	return 0;
//}

//int main()//逗号表达式  exp1,exp2,exp3,...expN   会从左到右依次计算  最后一个表达式的结果是整个表达式的结果
//{
//	int a = 1;
//	int b = 2;
//	int c = (a > b, a = b + 10, a, b = a + 1);//是13
//	printf("%d", c);
//	return 0;
//}

//int main()//条件操作符  exp1? exp2: exp3;    表达式1如果为真 那么就算表达式2 如果表达式1为假 那么就算表达式3 
//{
//	int a = 10;
//	int b = 20;
//	int max = 0;
//	if (a > b)
//		max = a;
//	else
//		max = b;
//
//	max=(a > b ? a : b);
//
//	//if (a > 5)
//	//	b = 3;
//	//else
//	//	b = -3;
//
//	//b=(a > 5 ? 3: -3);//三目操作符 条件操作符
//	return 0;
//}

//int main()
//{
//	int i = 0, a = 1, b = 2, c = 3, d = 4;
//	i = a++ || b++ || d++;//因为是或的关系 所以第一个为真 剩下的都不算了
//	printf("a=%d\n b=%d\n c=%d\n d=%d\n", a, b, c, d);//结果是2 2 3 4  因为
//	return 0;
//}


//int main()//360笔试题
//{
//	int i = 0, a = 0, b = 2, c = 3, d = 4;
//	i = a++ && b++ && d++;//因为是并且 所以一个为0 剩下的都不算  先计算后++ 所以之后a是1   &&左边算下是假 剩下都不算了
//	printf("a=%d\n b=%d\n c=%d\n d=%d\n", a, b, c, d);//结果是1 2 3 4   
//	return 0;
//}

//int main()
//{
//	int a = 0;
//	int b = 5;
//	int c = a || b;
//	printf("%d\n", c);//a或者b一个为真就是真  所以是1
//	return 0;
//}

//int main()//逻辑操作符  && 逻辑与  ||逻辑或   这两个用来判断真假
//{
//	int a = 3;
//	int b = 5;
//	int c = a && b;//a并且b  两个都为真  结果也是真  所以结果是1
//	printf("%d\n", c);
//	return 0;
//}

//int main()//（类型）-- 强制转换类型
//{
//	int a =(int) 3.14;//3.14是浮点型 不能用整型   把3.14强制转化成整型
//	printf("%d\n", a);
//	return 0;
//}

//int main()//
//{
//	int a = 10;
//	//printf("%d\n", ++a);//++放在前面是前置++   就是先++再使用  所以这里是11
//	printf("%d\n", a++);//后置++  先使用 再++
//	printf("%d\n", a);//这里是11    --也是这个意思
//	return 0;
//}

//int main()
//{
//	int a = 11;//最后是1011
//	//将倒数第三位改成1 值是15   可以用按位或  因为1或0还是1 0或1 就是1  或最后四位为0100  所以将1的二进制序列向左移2位
//	a=a | (1 << 2);//1向左移的两位
//	printf("%d\n", a);//再改回去  只要按位与只有倒数第三位是0的数就行了
//	a = a & ~((1 << 2));//&按位与
//	printf("%d\n", a);
//	return 0;
//}